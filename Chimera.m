(* ::Package:: *)

(************************************************************************)\012(* This file was generated automatically by the Mathematica front end.  *)\012(* It contains Initialization cells from a Notebook file, which         *)\012(* typically will have the same name as this file except ending in      *)\012(* ".nb" instead of ".m".                                               *)\012(*                                                                      *)\012(* This file is intended to be loaded into the Mathematica kernel using *)\012(* the package loading commands Get or Needs.  Doing so is equivalent   *)\012(* to using the Evaluate Initialization Cells menu command in the front *)\012(* end.                                                                 *)\012(*                                                                      *)\012(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)\012(* automatically each time the parent Notebook file is saved in the     *)\012(* Mathematica front end.  Any changes you make to this file will be    *)\012(* overwritten.                                                         *)\012(************************************************************************)\012\012

(* ::Input::Initialization:: *)
(* Chimera: Chiral Measures Research Assistant *)
(* \[Copyright] Emilio Pisanty, 2024 *)

(* For more information, see https://github.com/????/???? *)

(*TODO - update this*)


(* ::Input::Initialization:: *)
BeginPackage["Chimera`"];


(* ::Input::Initialization:: *)
$ChimeraVersion::usage="$ChimeraVersion prints the current version of the Chimera package in use and its timestamp.";
$ChimeraTimestamp::usage="$ChimeraTimestamp prints the timestamp of the current version of the Chimera package.";
Begin["`Private`"];
$ChimeraVersion:="Chimera v0.3, "<>$ChimeraTimestamp;
End[];


(* ::Input::Initialization:: *)
$ChimeraDirectory::usage="$ChimeraDirectory is the directory where the current Chimera package instance is located.";


(* ::Input::Initialization:: *)
Begin["`Private`"];
With[{softLinkTestString=StringSplit[StringJoin[ReadList["! ls -la "<>StringReplace[$InputFileName,{" "->"\\ "}],String]]," -> "]},
If[Length[softLinkTestString]>1,(*Testing in case $InputFileName is a soft link to the actual directory.*)
$ChimeraDirectory=StringReplace[DirectoryName[softLinkTestString[[2]]],{" "->"\\ "}],
$ChimeraDirectory=StringReplace[DirectoryName[$InputFileName],{" "->"\\ "}];
]];
End[];


(* ::Input::Initialization:: *)
$ChimeraCommit::usage="$ChimeraCommit returns the git commit log at the location of the Chimera package if there is one.";
$ChimeraCommit::OS="$ChimeraCommit has only been tested on Linux.";


(* ::Input::Initialization:: *)
Begin["`Private`"];
$ChimeraCommit:=(If[$OperatingSystem!="Unix",Message[$ChimeraCommit::OS]];
StringJoin[Riffle[ReadList["!cd "<>$ChimeraDirectory<>" && git log -1",String],{"\n"}]]);
End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];$ChimeraTimestamp="Fri 31 Oct 2025 19:10:32";End[];


(* ::Input::Initialization:: *)
LR={"L","R"};
LRA={"L","R","A"};


(* ::Input::Initialization:: *)
XYZ={"x","y","z"};


(* ::Input::Initialization:: *)
Unprotect[Sign];
Sign["L"]=1;
Sign["R"]=-1;
Sign["A"]=0;
Protect[Sign];


(* ::Input::Initialization:: *)
MegabyteCount[expr_]:=UnitConvert[Quantity[N@ByteCount[expr],"Bytes"],"Megabytes"]


(* ::Input::Initialization:: *)
electronCount[data_,h_]:=electronCount[data,h]=Total[data[h][[All,4]]]


(* ::Input::Initialization:: *)
SolidHarmonicS::usage="SolidHarmonicS[l,m,x,y,z] calculates the solid harmonic \!\(\*SubscriptBox[\(S\), \(lm\)]\)(x,y,z)=\!\(\*SuperscriptBox[\(r\), \(l\)]\)\!\(\*SubscriptBox[\(Y\), \(lm\)]\)(x,y,z).

SolidHarmonicS[l,m,{x,y,z}] does the same.";
Begin["`Private`"];

dpower[x_,y_]:=Piecewise[{{1,y==0}},x^y]

SolidHarmonicS[\[Lambda]_Integer,\[Mu]_Integer,x_,y_,z_]/;\[Lambda]>=Abs[\[Mu]]:=Times[
(*Sqrt[(2 \[Lambda]+1 )/(4 \[Pi] )],*)
Sqrt[(\[Lambda]-\[Mu])!(\[Lambda]+\[Mu])!],
Sum[If[
Or[p+q+r!=\[Lambda],p-q!=\[Mu]],0,
Times[
1/(p!q!r!),
dpower[-((x+I y)/2),p],
dpower[(x-I y)/2,q],
dpower[z,r]
]],{p,0,\[Lambda]},{q,0,\[Lambda]},{r,0,\[Lambda]}]
]
SolidHarmonicS[\[Lambda]_Integer,\[Mu]_Integer,{x_,y_,z_}]/;\[Lambda]>=Abs[\[Mu]]:=SolidHarmonicS[\[Lambda],\[Mu],x,y,z]
End[];


(* ::Input::Initialization:: *)
cleanContourPlot::usage="cleanContourPlot[plot] Cleans up a contour plot by coalescing complex polygons into single FilledCurve instances. See MM.SE/a/3279 for source and documentation.";


(* ::Input::Initialization:: *)
Begin["`Private`"];
cleanContourPlot[cp_] :=
 Module[{points, groups, regions, lines},
  groups = 
   Cases[cp, {style__, g_GraphicsGroup} :> {{style}, g}, Infinity];
  points = 
   First@Cases[cp, GraphicsComplex[pts_, ___] :> pts, Infinity];
  regions = Table[
    Module[{group, style, polys, edges, cover, graph},
     {style, group} = g;
     polys = Join @@ Cases[group, Polygon[pt_, ___] :> pt, Infinity];
     edges = Join @@ (Partition[#, 2, 1, 1] & /@ polys);
     cover = Cases[Tally[Sort /@ edges], {e_, 1} :> e];
     graph = Graph[UndirectedEdge @@@ cover];
     {Sequence @@ style, 
      FilledCurve[
       List /@ Line /@ First /@ 
          Map[First, 
           FindEulerianCycle /@ (Subgraph[graph, #] &) /@ 
             ConnectedComponents[graph], {3}]]}
     ],
    {g, groups}];
  lines = Cases[cp, _Tooltip, Infinity];
  Graphics[GraphicsComplex[points, {regions, lines}], 
   Sequence @@ Options[cp]]
  ]
End[];


(* ::Input::Initialization:: *)
photoElectronSpectrum::usage="photoElectronSpectrum[data,\[CapitalDelta]p] returns a histogram photoelectron spectrum for the given data set, which must be in the standard format, using bin width \[CapitalDelta]p.";

Begin["`Private`"];

photoElectronSpectrum[dataSet_,pBin_,options___]:=Block[{dataSet2,histogramAssoc},
If[
Dimensions[dataSet][[2]]==5,
dataSet2=dataSet,
dataSet2=Map[Join[#,{Norm[#[[1;;3]]]}]&,dataSet]
];
histogramAssoc=Map[
Total,
KeySort[GroupBy[dataSet2,Floor[#[[5]],pBin]&]][[1;;,All,4]]
];
Show[{
Graphics[{
EdgeForm[{Opacity[0.665`],Thickness[Small]}],
FaceForm[RGBColor[0.987148, 0.8073604000000001, 0.49470040000000004`]],
KeyValueMap[
Function[{p,value},Rectangle[{p,0},{p+pBin,value}]],
histogramAssoc
]
}]
}
,options
,Frame->True
,ImageSize->400
,AspectRatio->1/1.6
,PlotRangePadding->{{None,None},{None,Scaled[0.07]}}
]
]

End[];


(* ::Input::Initialization:: *)
photoElectronSpectrumList::usage="photoElectronSpectrumList[data,range,\[CapitalDelta]p] returns a histogram photoelectron spectrum for the data sets data[h], where h covers the given range, using bin width \[CapitalDelta]p.";

Begin["`Private`"];

photoElectronSpectrumList[dataSet_,range_,pBin_,options___]:=Map[
photoElectronSpectrum[dataSet[#],pBin,options,PlotLabel->#]&,
range]

End[];


(* ::Input::Initialization:: *)
SetSphericalDecomposition::usage="SetSphericalDecomposition[\[Rho]Symbol,dataSet] creates memoizable definitions for \[Rho]Symbol[h,\[ScriptL],m,{pmin,pmax}] to be the spherical decomposition with angular-momentum numbers \[ScriptL],m over momentum bin {pmin,pmax} for the dataset dataSet[h].";

Begin["`Private`"];

SetSphericalDecomposition[\[Rho]Symbol_,dataSet_]:=Block[{},
\[Rho]Symbol::usage=StringJoin[
ToString[\[Rho]Symbol],
"[h,\[ScriptL],m,{pmin,pmax}] memoizes and returns the spherical decomposition with angular-momentum numbers \[ScriptL],m over momentum bin {pmin,pmax} for the dataset ",
ToString[dataSet],
"[h]."
];
SetSharedFunction[\[Rho]Symbol];

\[Rho]Symbol[h_,\[ScriptL]_,m_/;(m>=0),{pmin_,pmax_}]:=Parallel`Developer`SendBack[
\[Rho]Symbol[h,\[ScriptL],m,{pmin,pmax}]=Block[{momentumFilteredData},
momentumFilteredData=Select[dataSet[h],pmin<#[[5]]<pmax&];
1/electronCount[dataSet,h] Sum[
record[[4]]SolidHarmonicS[\[ScriptL],m,record[[1;;3]]]\[Conjugate]
,{record,momentumFilteredData}]
]
];
\[Rho]Symbol[h_,\[ScriptL]_,m_/;(m<0),{pmin_,pmax_}]:=(-1)^m Conjugate[\[Rho]Symbol[h,\[ScriptL],-m,{pmin,pmax}]]
]

End[];


(* ::Input::Initialization:: *)
Options[SetExactSphericalDecomposition]=Options[NIntegrate];

SetExactSphericalDecomposition::usage="SetExactSphericalDecomposition[\[Rho]Symbol,PDF] creates memoizable definitions for \[Rho]Symbol[h,\[ScriptL],m,{pmin,pmax}] to be the spherical decomposition with angular-momentum numbers \[ScriptL],m over momentum bin {pmin,pmax} for the symbolic probability density function PDF[h].";

Begin["`Private`"];

SetExactSphericalDecomposition[\[Rho]Symbol_,PDF_,options:OptionsPattern[]]:=Block[{},
\[Rho]Symbol::usage=StringJoin[
ToString[\[Rho]Symbol],
"[h,\[ScriptL],m,{pmin,pmax}] memoizes and returns the spherical decomposition with angular-momentum numbers \[ScriptL],m over momentum bin {pmin,pmax}, numerically integrated for the PDF ",
ToString[PDF],
"[h]."
];
\[Rho]Symbol::integrationError="Encountered integration errors in the calculation of "<>ToString[\[Rho]Symbol]<>" with parameters {h,\[ScriptL],m,{pmin,pmax}}= `1`.";
\[Rho]Symbol::integrating="Beginning numerical integration for "<>ToString[\[Rho]Symbol]<>"[`1`,`2`,`3`,`4`]";
Off[\[Rho]Symbol::integrating];
SetSharedFunction[\[Rho]Symbol];

\[Rho]Symbol[h_,\[ScriptL]_,m_/;(m>=0),{pmin_,pmax_}]:=Parallel`Developer`SendBack[
\[Rho]Symbol[h,\[ScriptL],m,{pmin,pmax}]=Block[{pdf,fromSphericalCoordinates,integral},
pdf[{p_,\[Theta]_,\[Phi]_}]:=PDF[h][p,\[Theta],\[Phi]];
fromSphericalCoordinates[{pp_,\[Theta]_,\[Phi]_}]=FromSphericalCoordinates[{pp,\[Theta],\[Phi]}];
Message[\[Rho]Symbol::integrating,h,\[ScriptL],m,{pmin,pmax}];

Check[
integral=NIntegrate[
Times[
pdf[fromSphericalCoordinates[{p,\[Theta],\[Phi]}]],
SolidHarmonicS[\[ScriptL],m,fromSphericalCoordinates[{p,\[Theta],\[Phi]}]]\[Conjugate],
p^2 Sin[\[Theta]]
],{\[Theta],0,\[Pi]},{\[Phi],0,2\[Pi]},{p,pmin,pmax}
,Evaluate[Sequence@@FilterRules[{options},Options[NIntegrate]]]
],
Message[\[Rho]Symbol::integrationError,{h,\[ScriptL],m,{pmin,pmax}}];
integral
]
]
];
\[Rho]Symbol[h_,\[ScriptL]_,m_/;(m<0),{pmin_,pmax_}]:=(-1)^m Conjugate[\[Rho]Symbol[h,\[ScriptL],-m,{pmin,pmax}]]
]

End[];


(* ::Input::Initialization:: *)
Options[SetSymbolicSphericalDecomposition]={Assumptions->{}}(*Options[NIntegrate]*);

SetSymbolicSphericalDecomposition::usage="SetSymbolicSphericalDecomposition[\[Rho]Symbol,distribution] creates memoizable definitions for \[Rho]Symbol[\[ScriptL],m] to be the spherical decomposition with angular-momentum numbers \[ScriptL],m over momentum space for the given symbolic distribution.";

Begin["`Private`"];

SetSymbolicSphericalDecomposition[\[Rho]Symbol_,distribution_,options:OptionsPattern[]]:=Block[{},
\[Rho]Symbol::usage=StringJoin[
ToString[\[Rho]Symbol],
"[\[ScriptL],m] memoizes and returns the spherical decomposition with angular-momentum numbers \[ScriptL],m, symbollically calculated for the distribution ",
ToString[distribution],
"."
];
(*\[Rho]Symbol::integrationError="Encountered integration errors in the calculation of "<>ToString[\[Rho]Symbol]<>" with parameters {h,\[ScriptL],m}= `1`.";*)
\[Rho]Symbol::integrating="Beginning symbolic integration for "<>ToString[\[Rho]Symbol]<>"[`1`,`2`]";
Off[\[Rho]Symbol::integrating];
SetSharedFunction[\[Rho]Symbol];

\[Rho]Symbol[\[ScriptL]_,m_/;(m>=0)]:=Parallel`Developer`SendBack[
\[Rho]Symbol[\[ScriptL],m]=Block[{px,py,pz},
Message[\[Rho]Symbol::integrating,\[ScriptL],m];
Expectation[
SolidHarmonicS[\[ScriptL],m,{px,py,pz}]/.{I->-I},
{px,py,pz}\[Distributed]distribution
]
]
];
\[Rho]Symbol[\[ScriptL]_,m_/;(m<0)]:=Simplify[
(-1)^m Conjugate[\[Rho]Symbol[\[ScriptL],-m]]
,Assumptions->OptionValue[Assumptions]
]
]

End[];


(* ::Input::Initialization:: *)
\[Rho]1mToCartesian::usage="\[Rho]1mToCartesian[{\[Rho]1m1,\[Rho]10,\[Rho]11}]";

Begin["`Private`"];

\[Rho]1mToCartesian[{\[Rho]1m1_,\[Rho]10_,\[Rho]11_}]:=Chop[Sqrt[(2\[Pi])/3]{(\[Rho]11-\[Rho]1m1)/-1,(\[Rho]11+\[Rho]1m1)/I,Sqrt[2]\[Rho]10}]

End[];



(* ::Input::Initialization:: *)
\[Rho]ToCenterOfMass::usage="\[Rho]ToCenterOfMass[{{\[Rho]00},{\[Rho]1m1,\[Rho]10,\[Rho]11}}]";

Begin["`Private`"];

\[Rho]ToCenterOfMass[{{\[Rho]00_},{\[Rho]1m1_,\[Rho]10_,\[Rho]11_}}]:=Chop[(Sqrt[(2\[Pi])/3]{(\[Rho]11-\[Rho]1m1)/-1,(\[Rho]11+\[Rho]1m1)/I,Sqrt[2]\[Rho]10})/(2Sqrt[\[Pi]]\[Rho]00)]

End[];


(* ::Input::Initialization:: *)
ClearAll[COMfromPDF];

COMfromPDF::usage="COMfromPDF[PDF,{pmin,pmax},]";

Options[COMfromPDF]=Join[{PrecisionGoal->8,AccuracyGoal->8},DeleteCases[Options[NIntegrate],Alternatives[PrecisionGoal->_,AccuracyGoal->_]]];

COMfromPDF::integrationError="Encountered integration errors in the calculation of COMfromPDF with pdf `1` and {pmin,pmax}= `2`.";

SetSharedFunction[COMfromPDF];

Begin["`Private`"];

COMfromPDF[PDF_,{pmin_,pmax_},options:OptionsPattern[]]:=COMfromPDF[PDF,{pmin,pmax},options]=Block[{pdf,fromSphericalCoordinates,integrals},
pdf[{p_,\[Theta]_,\[Phi]_}]:=PDF[p,\[Theta],\[Phi]];
fromSphericalCoordinates[{pp_,\[Theta]_,\[Phi]_}]=FromSphericalCoordinates[{pp,\[Theta],\[Phi]}];

Check[
integrals=NIntegrate[
Times[
pdf[fromSphericalCoordinates[{p,\[Theta],\[Phi]}]],
Join[{1},fromSphericalCoordinates[{p,\[Theta],\[Phi]}]],
p^2 Sin[\[Theta]]
],{\[Theta],0,\[Pi]},{\[Phi],-\[Pi],\[Pi]},{p,pmin,pmax}
,Evaluate[Sequence@@FilterRules[{options},Options[NIntegrate]]]
];,
Message[COMfromPDF::integrationError,PDF,{pmin,pmax}];
];

;

integrals[[2;;4]]/integrals[[1]]
]

End[];


(* ::Input::Initialization:: *)
ClearAll[COMfromPDFcartesian];

COMfromPDFcartesian::usage="COMfromPDFcartesian[PDF,{pmin,pmax}]";

Options[COMfromPDFcartesian]=Join[{PrecisionGoal->8,AccuracyGoal->8},DeleteCases[Options[NIntegrate],Alternatives[PrecisionGoal->_,AccuracyGoal->_]]];

COMfromPDFcartesian::integrationError="Encountered integration errors in the calculation of COMfromPDFcartesian with pdf `1` and {pmin,pmax}= `2`.";

COMfromPDFcartesian::integrating="Beginning numerical integration for COMfromPDFcartesian[`1`,`2`]";
(*Off[COMfromPDFcartesian::integrating];*)

SetSharedFunction[COMfromPDFcartesian];

Begin["`Private`"];

COMfromPDFcartesian[PDF_,{pmin_,pmax_},options:OptionsPattern[]]:=COMfromPDFcartesian[PDF,{pmin,pmax},options]=Block[{integrals},
Message[COMfromPDFcartesian::integrating,PDF,{pmin,pmax}];

Check[
integrals=NIntegrate[
Times[
PDF[px,py,pz],
{1,px,py,pz},
Boole[pmin^2<px^2+py^2+pz^2<pmax^2]
],{px,-pmax,pmax},{py,-pmax,pmax},{pz,-pmax,pmax}
,Evaluate[Sequence@@FilterRules[{options},Options[NIntegrate]]]
];,
Message[COMfromPDFcartesian::integrationError,PDF,{pmin,pmax}];
];

;

integrals[[2;;4]]/integrals[[1]]
]

End[];


(* ::Input::Initialization:: *)
SetChiralityMeasure::usage="SetChiralityMeasure[\[Chi]Symbol,\[Rho]Symbol] creates memoizable definitions for \[Chi]Symbol[h,{\[ScriptL]1,\[ScriptL]2,\[ScriptL]3},{p1,p2,p3},\[CapitalDelta]p], which return the spherical chirality measure formed from the spherical decomposition \[Rho]Symbol with  helicity h, angular-momentum combination {\[ScriptL]1,\[ScriptL]2,\[ScriptL]3}, and with the corresponding spherical decompositions integrated between momenta p1, p2, p3 and p1+\[CapitalDelta]p, p2+\[CapitalDelta]p, p3+\[CapitalDelta]p, respectively.";

Begin["`Private`"];

SetChiralityMeasure[measureSymbol_,\[Rho]Symbol_]:=Block[{},
measureSymbol::usage=StringJoin[
ToString[measureSymbol],
"[h,{\[ScriptL]1,\[ScriptL]2,\[ScriptL]3},{p1,p2,p3},\[CapitalDelta]p] memoizes and returns the spherical chirality measure formed from the spherical decomposition ",
ToString[\[Rho]Symbol]," with the angular-momentum combination {\[ScriptL]1,\[ScriptL]2,\[ScriptL]3}, and with the corresponding spherical decompositions integrated between momenta p1, p2, p3 and p1+\[CapitalDelta]p, p2+\[CapitalDelta]p, p3+\[CapitalDelta]p, respectively."
];


measureSymbol[h_,{\[ScriptL]1_,\[ScriptL]2_,\[ScriptL]3_},{p1_,p2_,p3_},\[CapitalDelta]p_]:=Block[{},

(*Print["Beginning calculation of chirality measure ",measureSymbol," at parameters ",{h,{\[ScriptL]1,\[ScriptL]2,\[ScriptL]3},{p1,p2,p3},\[CapitalDelta]p}];*)

Sum[
If[
m1+m2+m3==0,
Times[
Quiet[
ThreeJSymbol[{\[ScriptL]1,m1},{\[ScriptL]2,m2},{\[ScriptL]3,m3}]
,ClebschGordan::phy],
\[Rho]Symbol[h,\[ScriptL]1,m1,{p1,p1+\[CapitalDelta]p}],
\[Rho]Symbol[h,\[ScriptL]2,m2,{p2,p2+\[CapitalDelta]p}],
\[Rho]Symbol[h,\[ScriptL]3,m3,{p3,p3+\[CapitalDelta]p}]
],
0
]
,{m1,-\[ScriptL]1,\[ScriptL]1},{m2,-\[ScriptL]2,\[ScriptL]2},{m3,-\[ScriptL]3,\[ScriptL]3}
]
]
]
End[];


(* ::Input::Initialization:: *)
SetSymbolicChiralityMeasure::usage="SetSymbolicChiralityMeasure[\[Chi]Symbol,\[Rho]Symbol] creates memoizable definitions for \[Chi]Symbol[{\[ScriptL]1,\[ScriptL]2,\[ScriptL]3}], which return the spherical chirality measure formed from the spherical decomposition \[Rho]Symbol with the angular-momentum combination {\[ScriptL]1,\[ScriptL]2,\[ScriptL]3}.";

Begin["`Private`"];

SetSymbolicChiralityMeasure[measureSymbol_,\[Rho]Symbol_]:=Block[{},
measureSymbol::usage=StringJoin[
ToString[measureSymbol],
"[{\[ScriptL]1,\[ScriptL]2,\[ScriptL]3}] memoizes and returns the spherical chirality measure formed from the spherical decomposition ",
ToString[\[Rho]Symbol]," with the angular-momentum combination {\[ScriptL]1,\[ScriptL]2,\[ScriptL]3}."
];


measureSymbol[{\[ScriptL]1_,\[ScriptL]2_,\[ScriptL]3_}]:=Block[{},

(*Print["Beginning calculation of chirality measure ",measureSymbol," at parameters ",{h,{\[ScriptL]1,\[ScriptL]2,\[ScriptL]3},{p1,p2,p3},\[CapitalDelta]p}];*)

Sum[
If[
m1+m2+m3==0,
Times[
Quiet[
ThreeJSymbol[{\[ScriptL]1,m1},{\[ScriptL]2,m2},{\[ScriptL]3,m3}]
,ClebschGordan::phy],
\[Rho]Symbol[\[ScriptL]1,m1],
\[Rho]Symbol[\[ScriptL]2,m2],
\[Rho]Symbol[\[ScriptL]3,m3]
],
0
]
,{m1,-\[ScriptL]1,\[ScriptL]1},{m2,-\[ScriptL]2,\[ScriptL]2},{m3,-\[ScriptL]3,\[ScriptL]3}
]
]
]

End[];


(* ::Input::Initialization:: *)
scaleBar::usage="scaleBar[\[Chi]Max]";

Begin["`Private`"];
scaleBar[\[Chi]Max_]:=ContourPlot[
y,{x,0,1},{y,-\[Chi]Max,\[Chi]Max}
,ImageSize->{{350},{350}}
,PlotRangePadding->None
,Contours->\[Chi]Max*Subdivide[-1.,1,16]
,ColorFunctionScaling->False
,ColorFunction->Function[Directive[Blend[{{-1,Blue},{0,White},{1,Red}},#/\[Chi]Max]]]
,AspectRatio->15
,FrameTicks->{{None,\[Chi]Max*Subdivide[-1.,1,16][[1;;;;2]]},{None,None}}
]

End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];
plotCOMvectorDirect[COMvector_,color_:Darker[Red]]:=Block[{COM=COMvector},
Graphics3D[{
color,
Tube[{{0,0,0},0.9COM},0.02Norm[COM]],
Cone[{0.85COM,COM},0.05Norm[COM]]
}]
]
End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];

plotCOMvector[\[Rho]Symbol_,h_,pInt_]:=Block[{COM},
COM=\[Rho]ToCenterOfMass[
Table[Table[
\[Rho]Symbol[h,\[ScriptL],m,pInt]
,{m,-\[ScriptL],\[ScriptL]}],{\[ScriptL],0,1}]
];

plotCOMvectorDirect[COM]
(*Graphics3D[{
Darker[Red],
Tube[{{0,0,0},0.9COM},0.02Norm[COM]],
Cone[{0.85COM,COM},0.075Norm[COM]]
}]*)
]

End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];

plotDistributionOnSphere[distribution_,p_,options:OptionsPattern[]]:=Block[{max},
max=NMaximize[
distribution@@FromSphericalCoordinates[{p,\[Theta],\[Phi]}]Sin[\[Theta]]
,{\[Theta],\[Phi]}][[1]];
ContourPlot3D[
px^2+py^2+pz^2==p^2
,{px,-1.1p,1.1p},{py,-1.1p,1.1p},{pz,-1.1p,1.1p}
,options
,ColorFunctionScaling->False
,ColorFunction->Function[{px,py,pz,pp},Blend[{RGBColor[1,1,1,0],Darker[Red,0.3]},1/max distribution[px,py,pz]]]
,MeshFunctions->{#1&,#2&,#3&,distribution[#1,#2,#3]&}
,MeshStyle->{Directive[GrayLevel[0.3],Opacity[0.25]],Directive[GrayLevel[0.3],Opacity[0.25]],Directive[GrayLevel[0.3],Opacity[0.25]],Black}
,Mesh->{10,10,10,15}
,AxesLabel->{"\!\(\*SubscriptBox[\(p\), \(x\)]\)","\!\(\*SubscriptBox[\(p\), \(y\)]\)","\!\(\*SubscriptBox[\(p\), \(z\)]\)"}
,SphericalRegion->True
,ImageSize->500
,PerformanceGoal->"Quality"
]
]

End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];

contourPlotOfDistributionOverSphericalShell[distribution_,p_,options:OptionsPattern[]]:=Block[{max},
max=NMaximize[
distribution@@FromSphericalCoordinates[{p,\[Theta],\[Phi]}]Sin[\[Theta]]
,{\[Theta],\[Phi]}][[1]];
cleanContourPlot[
ContourPlot[
Evaluate[
distribution@@FromSphericalCoordinates[{p,\[Theta],\[Phi]}]Sin[\[Theta]]
]
,{\[Phi],0,2\[Pi]},{\[Theta],0,\[Pi]}
,options
,PlotRangePadding->None
,AspectRatio->Automatic
,ImageSize->500
,PlotRange->Full
,ColorFunctionScaling->False
,ColorFunction->Function[dist,Blend[{RGBColor[1,1,1,0],Darker[Red,0.3]},1/max dist]]
]
]
]

End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];

plotCOMvectorTrio[\[Rho]Symbol_,h_,pIntervals_]:=Block[{COMs,s},
COMs=Table[
\[Rho]ToCenterOfMass[
Table[Table[
\[Rho]Symbol[h,\[ScriptL],m,pInt]
,{m,-\[ScriptL],\[ScriptL]}],{\[ScriptL],0,1}]
]
,{pInt,pIntervals}];
s=Mean[Norm/@COMs];

Show[{
Graphics3D[{
Darker[Red],
Table[{
Tube[{{0,0,0},0.9COM},0.02s],
Cone[{(1-0.15s)COM,COM},0.075s]
},{COM,COMs}],
Opacity[0.1],
Parallelepiped[{0,0,0},COMs]
}]
}
,SphericalRegion->True
,ImageSize->450
,PlotLabel->Det[COMs]
]
]

End[];


(* ::Input::Initialization:: *)
Begin["`Private`"];

calculate\[Rho]ScaledMax[\[Rho]Symbol_,\[ScriptL]max_?IntegerQ]:=calculate\[Rho]ScaledMax[\[Rho]Symbol,{0,\[ScriptL]max}]

calculate\[Rho]ScaledMax[\[Rho]Symbol_,{\[ScriptL]min_,\[ScriptL]max_}]:=Max[Flatten[Table[Table[
(*{\[ScriptL],m}->*)Abs[\[Rho]Symbol[\[ScriptL],m]]^(1/Max[\[ScriptL],1])
,{m,-\[ScriptL],\[ScriptL]}],{\[ScriptL],\[ScriptL]min,\[ScriptL]max}]]]

End[];


(* ::Input::Initialization:: *)
Options[sphericalDecompositionPlot]={ColorFunction->ColorData["BlueGreenYellow"],Tolerance->10.^-5,"OrderingFunction"->Im,"mFilter"->(True&)};


(* ::Input::Initialization:: *)
sphericalDecompositionPlot::usage="sphericalDecompositionPlot[\[Rho]Symbol,\[ScriptL]max] plots the spherical decomposition \[Rho]Symbol[\[ScriptL],m].
sphericalDecompositionPlot[\[Rho]Symbol,\[ScriptL]max,{\[ScriptL]1,\[ScriptL]2,\[ScriptL]3}]";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
sphericalDecompositionPlot[\[Rho]Symbol_,\[ScriptL]max_?IntegerQ,options:OptionsPattern[]]:=sphericalDecompositionPlot[\[Rho]Symbol,{0,\[ScriptL]max},options]
sphericalDecompositionPlot[\[Rho]Symbol_,{\[ScriptL]min_,\[ScriptL]max_},OptionsPattern[]]:=Block[{\[Rho]ScaledMax},
\[Rho]ScaledMax=calculate\[Rho]ScaledMax[\[Rho]Symbol,{\[ScriptL]min,\[ScriptL]max}];
Show[{
Table[
Table[
(*{\[ScriptL],m}->*)Graphics[{
OptionValue[ColorFunction][Abs[\[Rho]Symbol[\[ScriptL],m]]^((1/Max[\[ScriptL],1]))/\[Rho]ScaledMax],
Tooltip[
Rectangle[{m-1/2,\[ScriptL]-1/2},{m+1/2,\[ScriptL]+1/2}]
,Row[{"\[ScriptL]=",\[ScriptL],", m=",m,", |\!\(\*SubscriptBox[OverscriptBox[\(\[Rho]\), \(~\)], \(\[ScriptL], m\)]\)\!\(\*SuperscriptBox[\(|\), \(1/\[ScriptL]\)]\)=",Abs[\[Rho]Symbol[\[ScriptL],m]]^((1/Max[\[ScriptL],1]))/\[Rho]ScaledMax}]]
}]
,{m,-\[ScriptL],\[ScriptL]}]
,{\[ScriptL],\[ScriptL]min,\[ScriptL]max}]
}
,Frame->True
,ImageSize->650
,PlotRangePadding->None
,AspectRatio->Automatic
,FrameLabel->{"m","\[ScriptL]"}
,PlotLabel->"|\!\(\*SubscriptBox[\(\[Rho]\), \(\[ScriptL], m\)]\)\!\(\*SuperscriptBox[\(|\), \(1/max \((\[ScriptL], 1)\)\)]\)"
]
]


(* ::Input::Initialization:: *)
sphericalDecompositionPlot[\[Rho]Symbol_,\[ScriptL]max_,{\[ScriptL]1_,\[ScriptL]2_,\[ScriptL]3_},options:OptionsPattern[]]:=sphericalDecompositionPlot[\[Rho]Symbol,{0,\[ScriptL]max},{\[ScriptL]1,\[ScriptL]2,\[ScriptL]3},options]

sphericalDecompositionPlot[\[Rho]Symbol_,{\[ScriptL]min_,\[ScriptL]max_},{\[ScriptL]1_,\[ScriptL]2_,\[ScriptL]3_},options:OptionsPattern[]]:=Block[{\[Rho]ScaledMax,tolerance=OptionValue[Tolerance],W3j\[Rho]Product,W3j\[Rho]ProductMax},
\[Rho]ScaledMax=calculate\[Rho]ScaledMax[\[Rho]Symbol,{\[ScriptL]min,\[ScriptL]max}];
W3j\[Rho]ProductMax=Max[Abs/@Flatten[Table[
W3j\[Rho]Product[m1,m2,m3]=OptionValue["OrderingFunction"][Times[
Quiet[ThreeJSymbol[{\[ScriptL]1,m1},{\[ScriptL]2,m2},{\[ScriptL]3,m3}],ClebschGordan::phy],
\[Rho]Symbol[\[ScriptL]1,m1],
\[Rho]Symbol[\[ScriptL]2,m2],
\[Rho]Symbol[\[ScriptL]3,m3]
]]
,{m1,-\[ScriptL]1,\[ScriptL]1},{m2,-\[ScriptL]2,\[ScriptL]2},{m3,-\[ScriptL]3,\[ScriptL]3}]]];

Show[{

sphericalDecompositionPlot[\[Rho]Symbol,{\[ScriptL]min,\[ScriptL]max},options],

Graphics[{
White,
PointSize[0.01],
Values@KeySortBy[Last]@Association@Table[
If[
And[
Abs[W3j\[Rho]Product[m1,m2,m3]]/W3j\[Rho]ProductMax>=tolerance,
OptionValue["mFilter"][m1,m2,m3]
],
{m1,m2,m3,Abs[W3j\[Rho]Product[m1,m2,m3]]/W3j\[Rho]ProductMax}->{
Tooltip[{
Blend[{{-\[ScriptL]2,Orange},{0,Blend[{{-\[ScriptL]1,Red},{\[ScriptL]1,Blue}},m1]},{\[ScriptL]2,Darker[Green]}},m2],
EdgeForm[{Opacity[Abs[W3j\[Rho]Product[m1,m2,m3]]/W3j\[Rho]ProductMax],Thickness[0.001]}],
FaceForm[Opacity[0.8Abs[W3j\[Rho]Product[m1,m2,m3]]/W3j\[Rho]ProductMax]],
Triangle[{{m1,\[ScriptL]1},{m2,\[ScriptL]2},{m3,\[ScriptL]3}}],
Opacity[Abs[W3j\[Rho]Product[m1,m2,m3]]/W3j\[Rho]ProductMax],
Point[{{m1,\[ScriptL]1},{m2,\[ScriptL]2},{m3,\[ScriptL]3}}]
}
,Row[{{m1,m2,m3},"\[Rule]",Round[W3j\[Rho]Product[m1,m2,m3]/W3j\[Rho]ProductMax,0.01]}]]
}
,Nothing]
,{m1,-\[ScriptL]1,\[ScriptL]1},{m2,-\[ScriptL]2,\[ScriptL]2},{m3,-\[ScriptL]3,\[ScriptL]3}]
}]
}]
]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
RasterPlot3D::usage="RasterPlot3D[data]";


(* ::Input::Initialization:: *)
Begin["`Private`"];

RasterPlot3D[data_,options___:OptionsPattern[]]:=Block[{reshapedData},
Show[{
Graphics3D[{
Raster3D[
Map[
#[[1,4]]&,
Map[
Values,
GroupBy[
data,
{#[[3]]&,#[[2]]&,#[[1]]&}
]
,{0,2}]
,{3}],
Transpose[Table[MinMax[data[[All,i]]],{i,1,3}]],
MinMax[data[[All,4]]]
,Evaluate[Sequence@@FilterRules[{options},Options[Raster3D]]]
,ColorFunction->Function[Directive[Opacity[0.15#,Black]]]
]
}]
}
,Evaluate[Sequence@@FilterRules[{options},Options[Show]]]
,Axes->True
,AxesLabel->{"\!\(\*SubscriptBox[\(p\), \(x\)]\)","\!\(\*SubscriptBox[\(p\), \(y\)]\)","\!\(\*SubscriptBox[\(p\), \(z\)]\)"}
,BoxRatios->Automatic
,SphericalRegion->True
,ImageSize->700
]
]

End[];


(* ::Input::Initialization:: *)
TensorMultipoleOld::usage="TensorMultipoleOld[T,\[ScriptL]] returns the \[ScriptL]-polar component of the tensor T.
TensorMultipole[\[ScriptL]] gives the functionalized form of the projector onto \[ScriptL]-polar tensors.";

Begin["`Private`"];


(* ::Input::Initialization:: *)
TensorMultipoleOld[\[ScriptL]_][tensor_]:=TensorMultipoleOld[tensor,\[ScriptL]]


(* ::Input::Initialization:: *)
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==2),0]:=1/3 Tr[tensor]IdentityMatrix[3]
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==2),2]:=tensor-TensorMultipoleOld[tensor,0]


(* ::Input::Initialization:: *)
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==3),1]:=Normal[Symmetrize[
3/5 TensorProduct[
TensorContract[tensor,{{2,3}}],
IdentityMatrix[3]
]
]]
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==3),3]:=tensor-TensorMultipoleOld[tensor,1]


(* ::Input::Initialization:: *)
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==4),0]:=1/5 TensorContract[tensor,{{1,2},{3,4}}]Normal[Symmetrize[TensorProduct[
IdentityMatrix[3],
IdentityMatrix[3]
]]]
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==4),2]:=Normal[Symmetrize[
6/7 TensorProduct[
TensorContract[
tensor-TensorMultipoleOld[tensor,0]
,{{3,4}}],
IdentityMatrix[3]
]
]]
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==4),4]:=tensor-TensorMultipoleOld[tensor,2]-TensorMultipoleOld[tensor,0]


(* ::Input::Initialization:: *)
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==5),1]:=Normal[Symmetrize[
3/7 TensorProduct[
TensorContract[tensor,{{2,3},{4,5}}],
IdentityMatrix[3],
IdentityMatrix[3]
]
]]
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==5),3]:=Normal[Symmetrize[
10/9 TensorProduct[
TensorContract[tensor-TensorMultipoleOld[tensor,1],{{4,5}}],
IdentityMatrix[3]
]
]]
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==5),5]:=tensor-TensorMultipoleOld[tensor,3]-TensorMultipoleOld[tensor,1]


(* ::Input::Initialization:: *)
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==6),0]:=1/7 TensorContract[tensor,{{1,2},{3,4},{5,6}}]Normal[Symmetrize[TensorProduct[
IdentityMatrix[3],
IdentityMatrix[3],
IdentityMatrix[3]
]]]
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==6),2]:=Normal[Symmetrize[
5/7 TensorProduct[
TensorContract[
tensor-TensorMultipoleOld[tensor,0]
,{{3,4},{5,6}}],
IdentityMatrix[3],
IdentityMatrix[3]
]
]]
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==6),4]:=Normal[Symmetrize[
15/11 TensorProduct[
TensorContract[
tensor-TensorMultipoleOld[tensor,2]-TensorMultipoleOld[tensor,0]
,{{5,6}}],
IdentityMatrix[3]
]
]]
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==6),6]:=tensor-TensorMultipoleOld[tensor,4]-TensorMultipoleOld[tensor,2]-TensorMultipoleOld[tensor,0]


(* ::Input::Initialization:: *)
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==7),1]:=Normal[Symmetrize[
1/3 TensorProduct[
TensorContract[tensor,{{2,3},{4,5},{6,7}}],
IdentityMatrix[3],
IdentityMatrix[3],
IdentityMatrix[3]
]
]]
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==7),3]:=Normal[Symmetrize[
35/33 TensorProduct[
TensorContract[tensor-TensorMultipoleOld[tensor,1],{{4,5},{6,7}}],
IdentityMatrix[3],
IdentityMatrix[3]
]
]]
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==7),5]:=Normal[Symmetrize[
21/13 TensorProduct[
TensorContract[tensor-TensorMultipoleOld[tensor,3]-TensorMultipoleOld[tensor,1],{{6,7}}],
IdentityMatrix[3]
]
]]
TensorMultipoleOld[tensor_/;(ArrayDepth[tensor]==7),7]:=tensor-TensorMultipoleOld[tensor,5]-TensorMultipoleOld[tensor,3]-TensorMultipoleOld[tensor,1]


(* ::Input::Initialization:: *)
End[];


(* ::Input::Initialization:: *)
TensorCross::usage="TensorCross[A,B,k] returns the tensor cross product (A\[Times]B\!\(\*SubscriptBox[\()\), \(k\)]\) of the two tensors A and B with output rank k.";

Begin["`Private`"];
TensorCross[tensor1_,tensor2_,outputRank_]:=Normal[Symmetrize[
TensorContract[
TensorContract[
TensorProduct[LeviCivitaTensor[3],tensor1,tensor2],
{{2,4},{3,ArrayDepth[tensor1]+4}}
],
Table[{1+contractionIndex,ArrayDepth[tensor1]+contractionIndex},{contractionIndex,1,((ArrayDepth[tensor1]+ArrayDepth[tensor2]-1)-outputRank)/2}]
]
]]

End[];


(* ::Input::Initialization:: *)
TensorDot::usage="TensorDot[A,B] returns the full contraction of the two tensors A and B.";

Begin["`Private`"];

TensorDot[tensor1_,tensor2_]:=Activate[TensorContract[
Inactive[TensorProduct][tensor1,tensor2],
Table[{index,ArrayDepth[tensor1]+index},{index,1,ArrayDepth[tensor1]}]
]]

End[];


(* ::Input::Initialization:: *)
TensorPower::usage="TensorPower[T,n] returns the tensor power \!\(\*SuperscriptBox[\(T\), \(\[CircleTimes]n\)]\).";

Begin["`Private`"];

TensorPower[tensor_,n_]:=TensorProduct@@Table[tensor,{n}]

End[];


(* ::Input::Initialization:: *)
MultipolePower::usage="MultipolePower[v,\[ScriptL]] returns the \[ScriptL]-polar component of \!\(\*SuperscriptBox[\(v\), \(\[CircleTimes]\[ScriptL]\)]\), for a vector v.";

Begin["`Private`"];

MultipolePower[v_,\[ScriptL]_]:=TensorMultipole[TensorPower[v,\[ScriptL]],\[ScriptL]]

End[];


(* ::Input::Initialization:: *)
TensorPolynomial::usage="TensorPolynomial[T,v] returns the polynomial T\[CenterDot]\!\(\*SuperscriptBox[\(v\), \(\[CircleTimes]k\)]\)=\!\(\*SubscriptBox[\(T\), \(\*SubscriptBox[\(i\), \(1\)] \*SubscriptBox[\(\[CenterEllipsis]i\), \(k\)]\)]\)\!\(\*SubscriptBox[\(v\), SubscriptBox[\(i\), \(1\)]]\)\!\(\*SubscriptBox[\(\[CenterEllipsis]v\), SubscriptBox[\(i\), \(k\)]]\).";

Begin["`Private`"];

TensorPolynomial[tensor_,vector_]:=TensorDot[tensor,TensorPower[vector,ArrayDepth[tensor]]]

End[];


(* ::Input::Initialization:: *)
UnitE::usage="UnitE[s] returns the spherical basis vector \!\(\*SubscriptBox[\(e\), \(s\)]\).";

Begin["`Private`"];
UnitE[1]:=-(1/Sqrt[2]){1,I,0}
UnitE[-1]:=1/Sqrt[2] {1,-I,0}
UnitE[0]:={0,0,1}
End[];


(* ::Input::Initialization:: *)
(*MultipolarBasisTensorT::usage="MultipolarBasisTensorT[\[ScriptL],m] returns the multipolar basis tensor Subscript[Overscript[t, ^], l,m].";

Begin["`Private`"];

MultipolarBasisTensorT[\[Lambda]_Integer,\[Mu]_Integer]/;\[Lambda]\[GreaterEqual]Abs[\[Mu]]:=Times[
(*Sqrt[(2 \[Lambda]+1 )/(4 \[Pi] )],*)
Sqrt[(\[Lambda]-\[Mu])!(\[Lambda]+\[Mu])!],
Sum[If[
Or[p+q+r!=\[Lambda],p-q!=\[Mu]],0,
2^(-((p+q)/2))/(p!q!r!)\[Times]Symmetrize[TensorProduct[
TensorPower[UnitE[1],p],
TensorPower[UnitE[-1],q],
TensorPower[UnitE[0],r]
]]
],{p,0,\[Lambda]},{q,0,\[Lambda]},{r,0,\[Lambda]}]
]

End[];*)


(* ::Input::Initialization:: *)
MultipolarBasisTensorT::usage="MultipolarBasisTensorT[\[ScriptL],m] returns the multipolar basis tensor \!\(\*SubscriptBox[OverscriptBox[\(t\), \(^\)], \(l, m\)]\).
MultipolarBasisTensorT[n,\[ScriptL],m] returns the multipolar basis tensor \!\(\*SubsuperscriptBox[OverscriptBox[\(t\), \(^\)], \(l, m\), \((n)\)]\) with tensor rank n.";

Begin["`Private`"];

MultipolarBasisTensorT[n_Integer,\[ScriptL]_Integer,m_Integer]/;And[Abs[m]<=\[ScriptL]<=n,EvenQ[n-\[ScriptL]]]:=Times[
(-1)^m,
Sqrt[b[\[ScriptL],(n-\[ScriptL])/2]],
Sqrt[\[ScriptL]!/(2\[ScriptL]-1)!!],
Sqrt[(\[ScriptL]-m)!(\[ScriptL]+m)!],
Sum[If[
Or[p+q+r!=\[ScriptL],p-q!=m],0,
2^(-((p+q)/2))/(p!q!r!)*Symmetrize[TensorProduct[
TensorPower[UnitE[-1],p],
TensorPower[UnitE[1],q],
TensorPower[UnitE[0],r],
TensorPower[IdentityMatrix[3],(n-\[ScriptL])/2]
]]
],{p,0,\[ScriptL]},{q,0,\[ScriptL]},{r,0,\[ScriptL]}]
]

MultipolarBasisTensorT[\[ScriptL]_,m_]:=MultipolarBasisTensorT[\[ScriptL],\[ScriptL],m]

End[];


(* ::Input::Initialization:: *)
TensorLift::usage="TensorLift[A] returns the tensor lift \!\(\*OverscriptBox[\(\[ScriptCapitalL]\), \(^\)]\)(A)=\!\(\*OverscriptBox[\(\[ScriptCapitalS]\), \(^\)]\)(A\[CircleTimes]I) for the given tensor A.";

Begin["`Private`"];
TensorLift[tensor_List|tensor_SymmetrizedArray]:=Symmetrize[
TensorProduct[
tensor,
IdentityMatrix[3]
]
]
TensorLift[scalar_]:=scalar IdentityMatrix[3]

End[];


(* ::Input::Initialization:: *)
TensorTrace::usage="TensorTrace[A] returns the tensor trace Tr(A), contracted on the first and second indices.";

Begin["`Private`"];
TensorTrace[tensor_]:=TensorContract[tensor,{{1,2}}]

End[];


(* ::Input::Initialization:: *)
TensorMultipole::usage="TensorMultipole[T,\[ScriptL],n] returns the \[ScriptL]-polar component of a tensor T of rank n.
TensorMultipole[\[ScriptL],n] gives the functionalized form of the projector onto \[ScriptL]-polar tensors of rank n.
TensorMultipole[\[ScriptL]] gives the functionalized form of the projector onto \[ScriptL]-polar tensors of rank \[ScriptL].";

Begin["`Private`"];

dim=3;
b[n_,m_]:=((n+2m)!(2n-2+dim)!!)/(2^m m!n!(2n+2(m-1)+dim)!!)
c[n_,\[ScriptL]_]:=((n+2)(n+1))/((n+2-\[ScriptL])(n+\[ScriptL]+dim))

TensorMultipole[tensor_,\[ScriptL]_,n_]/;And[EvenQ[n-\[ScriptL]],n>=\[ScriptL]]:=Function[
projectedTensor,
b[\[ScriptL],(n-\[ScriptL])/2]Nest[TensorLift,(n-\[ScriptL])/2]@(
projectedTensor-Sum[
TensorMultipole[projectedTensor,\[ScriptL]\[ScriptL],\[ScriptL]]
,{\[ScriptL]\[ScriptL],Mod[\[ScriptL],2],\[ScriptL]-2,2}]
)
][
Nest[TensorTrace,tensor,(n-\[ScriptL])/2]
]

(TensorMultipole[\[ScriptL]_,n_]/;And[EvenQ[n-\[ScriptL]],n>=\[ScriptL]])[tensor_]:=TensorMultipole[tensor,\[ScriptL],n]
TensorMultipole[\[ScriptL]_][tensor_]:=TensorMultipole[tensor,\[ScriptL],\[ScriptL]]

End[];


(* ::Input::Initialization:: *)
EndPackage[];


(* ::Input::Initialization:: *)
DistributeDefinitions["Chimera`"];
